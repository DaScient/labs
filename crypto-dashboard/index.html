<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RLBot Live Performance</title>
<meta name="theme-color" content="#0b0d12" />
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<style>
  :root{
    --bg:#0b0d12;--panel:#101422;--panel-2:#0e1220;--ink:#e6e7ee;--muted:#9aa3b2;--accent:#7dd3fc;
    --good:#16a34a;--bad:#ef4444;--hold:#f59e0b;--chip:#1b2234;--border:#1c2335
  }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(1200px 800px at 20% -10%, #12162a 0%, var(--bg) 50%) fixed;color:var(--ink);font:500 15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  header{position:sticky;top:0;z-index:8;backdrop-filter: blur(6px);background:linear-gradient(180deg,rgba(11,13,18,.86),rgba(11,13,18,.65) 60%,rgba(11,13,18,0));border-bottom:1px solid var(--border)}
  .wrap{max-width:1240px;margin:0 auto;padding:16px}
  .top{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .brand{font-weight:900;letter-spacing:.3px;font-size:18px;padding:6px 10px;border-radius:12px;background:linear-gradient(90deg,#5eead4,#7dd3fc);color:#0b1220;box-shadow:0 0 0 3px rgba(125,211,252,.12) inset}
  .chip{display:inline-flex;align-items:center;gap:8px;background:var(--chip);padding:6px 10px;border-radius:999px;border:1px solid var(--border);color:#c7d2fe;font-size:13px;text-decoration:none}
  input[type=text],select,button{padding:9px 12px;border-radius:12px;border:1px solid var(--border);background:#0f1526;color:var(--ink);outline:none}
  button{cursor:pointer;font-weight:800;letter-spacing:.2px}
  button.primary{background:linear-gradient(90deg,#38bdf8,#22d3ee);color:#091225;border:none}
  main .grid{display:grid;gap:12px;margin-top:12px;grid-template-columns:1.2fr .8fr}
  @media (max-width:1080px){ main .grid{grid-template-columns:1fr} }
  .panel{background:linear-gradient(180deg,var(--panel),var(--panel-2));border:1px solid var(--border);border-radius:16px;padding:12px;box-shadow:0 12px 30px rgba(3,6,12,.35)}
  .h2{font-weight:900;margin:2px 0 10px}
  .metrics{display:flex;gap:10px;flex-wrap:wrap}
  .kpi{min-width:120px;background:#0d1222;border:1px solid var(--border);border-radius:12px;padding:10px}
  .kpi .label{color:var(--muted);font-size:12px}
  .kpi .val{font-size:22px;font-weight:900;margin-top:2px}
  .gridCards{display:grid;gap:12px;grid-template-columns:repeat(4, minmax(220px, 1fr))}
  @media (max-width:1200px){ .gridCards{grid-template-columns:repeat(3, minmax(220px, 1fr))}}
  @media (max-width:900px){ .gridCards{grid-template-columns:repeat(2, minmax(220px, 1fr))}}
  @media (max-width:600px){ .gridCards{grid-template-columns:1fr}}
  .card{background:linear-gradient(180deg,#0e1323,#0c1120);border:1px solid var(--border);border-radius:14px;padding:12px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .pill{font-weight:900;padding:6px 10px;border-radius:999px;border:1px solid var(--border);font-size:12px}
  .pill.buy{background:rgba(22,163,74,.15);color:#86efac;border-color:rgba(22,163,74,.35)}
  .pill.sell{background:rgba(239,68,68,.15);color:#fecaca;border-color:rgba(239,68,68,.35)}
  .pill.hold{background:rgba(245,158,11,.12);color:#fde68a;border-color:rgba(245,158,11,.3)}
  .muted{color:var(--muted);font-size:12px}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .footer{color:#7f8aa3;font-size:12px;padding:20px 16px 40px;text-align:center}
</style>
</head>
<body>
<header>
  <div class="wrap top">
    <div class="brand">RLBot Live Performance</div>
    <a class="chip" id="pingLink" target="_blank" rel="noopener">/api/ping</a>
    <input id="symbols" type="text" style="min-width:340px"
      placeholder="BTC/USDT, ETH/USDT, SOL/USDT, DOGE/USDT" />
    <select id="provider">
      <option value="okx" selected>OKX</option>
      <option value="binance">Binance</option>
      <option value="bybit">Bybit</option>
    </select>
    <button class="primary" id="applyBtn">Apply</button>
    <span class="chip" id="statusChip">status: —</span>
  </div>
</header>

<main class="wrap">
  <div class="grid">
    <section class="panel">
      <div class="row" style="justify-content:space-between">
        <div class="h2">Portfolio Equity</div>
        <div class="muted">since <span id="asOf" class="mono">—</span></div>
      </div>
      <canvas id="eqChart" height="150"></canvas>
    </section>

    <section class="panel">
      <div class="h2">Performance Metrics</div>
      <div class="metrics">
        <div class="kpi"><div class="label">Cumulative Return</div><div class="val mono" id="mRet">—</div></div>
        <div class="kpi"><div class="label">Sharpe (daily)</div><div class="val mono" id="mSharpe">—</div></div>
        <div class="kpi"><div class="label">Max Drawdown</div><div class="val mono" id="mDD">—</div></div>
        <div class="kpi"><div class="label">Win Rate</div><div class="val mono" id="mWin">—</div></div>
      </div>
      <div class="muted" style="margin-top:8px">* Metrics computed from your locally accumulated trade history (persists in this browser).</div>
      <div class="row" style="margin-top:10px"><button id="resetBtn">Reset History</button><span id="navNow" class="mono muted"></span></div>
    </section>
  </div>

  <section class="panel" style="margin-top:12px">
    <div class="h2">Symbols</div>
    <div class="gridCards" id="cards"></div>
    <div class="muted" style="margin-top:8px">Signals are the Worker’s output. We simulate paper trades: <b>BUY → long</b>, <b>SELL → short</b>, <b>HOLD → maintain</b>; equal <b>dollar</b> weight per symbol.</div>
  </section>

  <div class="footer">For education only. Not investment advice.</div>
</main>

<script>
/* ========= CONFIG ========= */
const WORKER_BASE = location.origin; // host this index next to your worker. Override if needed.
const BATCH_EP = (csv, prov) => `${WORKER_BASE}/api/summary-batch?symbols=${encodeURIComponent(csv)}&provider=${encodeURIComponent(prov)}`;
const PING_EP  = `${WORKER_BASE}/api/ping`;

const POLL_MS = 60_000;
const MAX_POINTS = 5000;
const DOLLAR_NOTIONAL = 100;   // equal $ exposure per symbol
const CONF_GATE = 0.55;        // ignore signals below this confidence
const HYST_BUF = 5;            // score buffer before flipping (if score is present)

/* ========= STATE & STORAGE ========= */
const LS_KEYS = {
  cfg: "rl_cfg_v2",
  per: "rl_per_v2",
  hist: "rl_hist_v2"
};

function loadLS(key, fallback) {
  try { const v = localStorage.getItem(key); return v? JSON.parse(v) : fallback; } catch { return fallback; }
}
function saveLS(key, val) { try { localStorage.setItem(key, JSON.stringify(val)); } catch {} }

let config = loadLS(LS_KEYS.cfg, {
  symbols: "BTC/USDT, ETH/USDT, SOL/USDT, DOGE/USDT",
  provider: "okx"
});
let perSym = loadLS(LS_KEYS.per, {});     // sym -> {pos, entry, qty, realized, last, trades[]}
let navHistory = loadLS(LS_KEYS.hist, []); // [{t, nav: equityValue}]
let timer = null;

/* ========= DOM ========= */
const el = (id) => document.getElementById(id);
el("symbols").value = config.symbols;
el("provider").value = config.provider;
el("pingLink").href = PING_EP;

el("applyBtn").addEventListener("click", () => {
  config.symbols = el("symbols").value.trim();
  config.provider = el("provider").value;
  saveLS(LS_KEYS.cfg, config);
  startPolling(true);
});
el("resetBtn").addEventListener("click", () => {
  perSym = {};
  navHistory = [];
  saveLS(LS_KEYS.per, perSym);
  saveLS(LS_KEYS.hist, navHistory);
  drawPortfolio(); renderLiveMetrics();
  renderCards([]);
});

/* ========= CHART ========= */
let eqChart;
function initChart(){
  const ctx = el("eqChart").getContext("2d");
  eqChart = new Chart(ctx, {
    type: "line",
    data: { labels: [], datasets: [{ label: "Equity (NAV)", data: [], tension: .25, borderWidth: 2 }] },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      color: "#cbd5e1",
      scales: { x: { ticks: { color:"#9aa3b2" } }, y:{ ticks:{ color:"#9aa3b2" } } },
      plugins: {
        legend: { labels: { color:"#e5e7eb" } },
        tooltip: { callbacks: { label: (c)=>` ${c.parsed.y.toFixed(2)}` } }
      },
      elements: { point: { radius: 0 } }
    }
  });
}
initChart();

/* ========= HELPERS ========= */
const fmt = (n, d=2) => (n==null || !isFinite(n)) ? "—" : Number(n).toLocaleString(undefined,{maximumFractionDigits:d});
const cssSignal = s => s==="BUY"?"buy":s==="SELL"?"sell":"hold";

/* ========= PORTFOLIO ENGINE ========= */
function updatePortfolio(rows){
  const now = Date.now();
  let realized = 0, unreal = 0;

  for (const r of rows || []){
    const sym = (r.symbol||"").toUpperCase(); if (!sym) continue;
    if (!perSym[sym]) perSym[sym] = {pos:0, entry:0, qty:0, realized:0, last:null, trades:[]};

    const ps = perSym[sym];
    const price = (typeof r.price==='number') ? r.price : ps.last; if (price==null) continue;

    // Decide target with confidence gate + hysteresis on score if available
    let target = ps.pos;
    if (typeof r.confidence === "number" && r.confidence >= CONF_GATE) {
      if (r.signal === "BUY") target = +1;
      else if (r.signal === "SELL") target = -1;
    }
    // Hysteresis: prevent immediate flip unless score crosses opposite th by buffer
    const sc = typeof r.score === "number" ? r.score : 0;
    if (ps.pos === +1 && sc > -(25) + HYST_BUF) target = +1;
    if (ps.pos === -1 && sc < (25) - HYST_BUF) target = -1;

    // Flip/close if changed
    if (target !== ps.pos){
      if (ps.pos !== 0 && ps.entry!=null && ps.qty>0){
        const pnl = (price - ps.entry) * ps.qty * ps.pos;
        ps.realized += pnl;
        ps.trades.push({t:now, side:(ps.pos>0?'CloseLong':'CloseShort'), price, pnl});
      }
      if (target !== 0){
        ps.entry = price;
        ps.qty   = DOLLAR_NOTIONAL / Math.max(1e-9, price); // equal $ exposure
        ps.trades.push({t:now, side:(target>0?'OpenLong':'OpenShort'), price, qty:ps.qty});
      } else {
        ps.qty = 0;
      }
      ps.pos = target;
    }

    if (ps.pos !== 0 && ps.entry!=null && ps.qty>0){
      unreal += (price - ps.entry) * ps.qty * ps.pos;
    }
    realized += ps.realized;
    ps.last = price;
  }

  // Book size & equity
  const nSyms = Math.max(1, Object.keys(perSym).length);
  const initialCapital = nSyms * DOLLAR_NOTIONAL;
  const nav = realized + unreal;
  const equity = initialCapital + nav;

  navHistory.push({t:now, nav: equity});
  if (navHistory.length > MAX_POINTS) navHistory = navHistory.slice(-MAX_POINTS);
  saveLS(LS_KEYS.per, perSym);
  saveLS(LS_KEYS.hist, navHistory);

  el("navNow").textContent = `NAV ${nav>=0?'+':''}${fmt(nav,2)} (Equity ${fmt(equity,2)})`;
  el("asOf").textContent = new Date(now).toLocaleString();
  drawPortfolio(); renderLiveMetrics(initialCapital);
}

function drawPortfolio(){
  if (!eqChart) return;
  const labels = navHistory.map(p=> new Date(p.t).toLocaleTimeString());
  const data = navHistory.map(p=> p.nav);
  eqChart.data.labels = labels;
  eqChart.data.datasets[0].data = data;
  eqChart.update("none");
}

function renderLiveMetrics(initialCapitalGuess){
  const eq = navHistory.map(p=>p.nav);
  if (eq.length<2){
    el("mRet").textContent="—";
    el("mSharpe").textContent="—";
    el("mDD").textContent="—";
    el("mWin").textContent="—";
    return;
  }
  const r=[]; for(let i=1;i<eq.length;i++){ r.push( (eq[i]-eq[i-1]) / Math.max(1e-9, eq[i-1]) ); }
  const mean = r.reduce((a,b)=>a+b,0)/r.length;
  const sd = Math.sqrt(r.reduce((a,b)=>a+(b-mean)*(b-mean),0)/Math.max(1,r.length-1));
  const sharpe = sd ? (mean/sd)*Math.sqrt(1440) : 0;
  const base = eq[0] || initialCapitalGuess || 1;
  const cum = (eq.at(-1)-base)/Math.max(1e-9, base);
  let peak=eq[0], maxDD=0; for(const v of eq){ peak=Math.max(peak,v); maxDD=Math.min(maxDD,(v-peak)/Math.max(1e-9,peak)); }

  // Win rate from realized trades
  let wins=0,losses=0;
  for (const k in perSym){ for (const t of (perSym[k].trades||[])) if (typeof t.pnl==="number"){ if (t.pnl>0) wins++; else if (t.pnl<0) losses++; } }

  el("mRet").textContent=`${(cum*100).toFixed(2)}%`;
  el("mSharpe").textContent=`${isFinite(sharpe)?sharpe.toFixed(2):"0.00"}`;
  el("mDD").textContent=`${(Math.abs(maxDD)*100).toFixed(2)}%`;
  el("mWin").textContent=`${((wins/(wins+losses||1))*100).toFixed(0)}%`;
}

/* ========= SYMBOL CARDS ========= */
function renderCards(rows){
  const box = el("cards");
  box.innerHTML = (rows||[]).map(r=>{
    const sclass = cssSignal(r.signal||"HOLD");
    const pos = perSym[(r.symbol||"").toUpperCase()]?.pos || 0;
    const posTxt = pos>0? "Long" : pos<0? "Short" : "Flat";
    const realized = perSym[(r.symbol||"").toUpperCase()]?.realized ?? 0;
    const notes = (r.ta?.notes||[]).join(", ");
    return `
      <div class="card">
        <div class="row" style="justify-content:space-between;margin-bottom:6px">
          <div style="font-weight:900">${(r.symbol||'—').toUpperCase()}</div>
          <span class="pill ${sclass}">${(r.signal||'HOLD')}</span>
        </div>
        <div class="muted mono">Price: ${fmt(r.price, r.price>1000?0:4)} &nbsp; • &nbsp; Score: ${fmt(r.score,0)}</div>
        <div class="muted mono">Conf: ${fmt((r.confidence||0)*100,0)}% &nbsp; • &nbsp; Pos: ${posTxt}</div>
        <div class="muted mono">Realized: ${fmt(realized,2)}</div>
        <div class="muted" style="margin-top:6px">Provider: ${(r._provider||'—')} &nbsp; • &nbsp; TA notes: ${notes||'—'}</div>
      </div>
    `;
  }).join("");
}

/* ========= POLLING ========= */
async function pollOnce(){
  const t0 = performance.now();
  const csv = config.symbols;
  const prov = config.provider || "okx";
  const url = BATCH_EP(csv, prov);
  el("statusChip").textContent = "status: …";
  try{
    const resp = await fetch(url, { headers: { "accept":"application/json" }});
    const ms = Math.round(performance.now() - t0);
    el("statusChip").textContent = `status: ${resp.status} in ${ms}ms (${prov})`;
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    const rows = Array.isArray(data)? data : [];
    updatePortfolio(rows);
    renderCards(rows);
  }catch(e){
    const ms = Math.round(performance.now() - t0);
    el("statusChip").textContent = `network error in ${ms}ms (${prov})`;
    // keep previous state; no throw
  }
}

function startPolling(immediate=false){
  if (timer) clearInterval(timer);
  saveLS(LS_KEYS.cfg, config);
  pollOnce();
  timer = setInterval(pollOnce, POLL_MS);
  if (immediate) pollOnce();
}

/* ========= BOOT ========= */
startPolling(true);
</script>
</body>
</html>
